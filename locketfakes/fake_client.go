// This file was generated by counterfeiter
package locketfakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry-incubator/locket"
	"github.com/cloudfoundry-incubator/runtime-schema/models"
	"github.com/tedsuo/ifrit"
)

type FakeClient struct {
	NewAuctioneerLockStub        func(auctioneerPresence models.AuctioneerPresence, retryInterval time.Duration) (ifrit.Runner, error)
	newAuctioneerLockMutex       sync.RWMutex
	newAuctioneerLockArgsForCall []struct {
		auctioneerPresence models.AuctioneerPresence
		retryInterval      time.Duration
	}
	newAuctioneerLockReturns struct {
		result1 ifrit.Runner
		result2 error
	}
	NewConvergeLockStub        func(convergerID string, retryInterval time.Duration) ifrit.Runner
	newConvergeLockMutex       sync.RWMutex
	newConvergeLockArgsForCall []struct {
		convergerID   string
		retryInterval time.Duration
	}
	newConvergeLockReturns struct {
		result1 ifrit.Runner
	}
	NewNsyncBulkerLockStub        func(bulkerID string, retryInterval time.Duration) ifrit.Runner
	newNsyncBulkerLockMutex       sync.RWMutex
	newNsyncBulkerLockArgsForCall []struct {
		bulkerID      string
		retryInterval time.Duration
	}
	newNsyncBulkerLockReturns struct {
		result1 ifrit.Runner
	}
	NewRouteEmitterLockStub        func(emitterID string, retryInterval time.Duration) ifrit.Runner
	newRouteEmitterLockMutex       sync.RWMutex
	newRouteEmitterLockArgsForCall []struct {
		emitterID     string
		retryInterval time.Duration
	}
	newRouteEmitterLockReturns struct {
		result1 ifrit.Runner
	}
	NewRuntimeMetricsLockStub        func(runtimeMetricsID string, retryInterval time.Duration) ifrit.Runner
	newRuntimeMetricsLockMutex       sync.RWMutex
	newRuntimeMetricsLockArgsForCall []struct {
		runtimeMetricsID string
		retryInterval    time.Duration
	}
	newRuntimeMetricsLockReturns struct {
		result1 ifrit.Runner
	}
	NewTpsWatcherLockStub        func(tpsWatcherID string, retryInterval time.Duration) ifrit.Runner
	newTpsWatcherLockMutex       sync.RWMutex
	newTpsWatcherLockArgsForCall []struct {
		tpsWatcherID  string
		retryInterval time.Duration
	}
	newTpsWatcherLockReturns struct {
		result1 ifrit.Runner
	}
	NewBBSMasterLockStub        func(bbsPresence models.BBSPresence, retryInterval time.Duration) (ifrit.Runner, error)
	newBBSMasterLockMutex       sync.RWMutex
	newBBSMasterLockArgsForCall []struct {
		bbsPresence   models.BBSPresence
		retryInterval time.Duration
	}
	newBBSMasterLockReturns struct {
		result1 ifrit.Runner
		result2 error
	}
	AuctioneerAddressStub        func() (string, error)
	auctioneerAddressMutex       sync.RWMutex
	auctioneerAddressArgsForCall []struct{}
	auctioneerAddressReturns struct {
		result1 string
		result2 error
	}
	BBSMasterURLStub        func() (string, error)
	bBSMasterURLMutex       sync.RWMutex
	bBSMasterURLArgsForCall []struct{}
	bBSMasterURLReturns struct {
		result1 string
		result2 error
	}
	NewCellPresenceStub        func(cellPresence models.CellPresence, retryInterval time.Duration) ifrit.Runner
	newCellPresenceMutex       sync.RWMutex
	newCellPresenceArgsForCall []struct {
		cellPresence  models.CellPresence
		retryInterval time.Duration
	}
	newCellPresenceReturns struct {
		result1 ifrit.Runner
	}
	CellByIdStub        func(cellId string) (models.CellPresence, error)
	cellByIdMutex       sync.RWMutex
	cellByIdArgsForCall []struct {
		cellId string
	}
	cellByIdReturns struct {
		result1 models.CellPresence
		result2 error
	}
	CellsStub        func() ([]models.CellPresence, error)
	cellsMutex       sync.RWMutex
	cellsArgsForCall []struct{}
	cellsReturns struct {
		result1 []models.CellPresence
		result2 error
	}
	CellEventsStub        func() <-chan locket.CellEvent
	cellEventsMutex       sync.RWMutex
	cellEventsArgsForCall []struct{}
	cellEventsReturns struct {
		result1 <-chan locket.CellEvent
	}
}

func (fake *FakeClient) NewAuctioneerLock(auctioneerPresence models.AuctioneerPresence, retryInterval time.Duration) (ifrit.Runner, error) {
	fake.newAuctioneerLockMutex.Lock()
	fake.newAuctioneerLockArgsForCall = append(fake.newAuctioneerLockArgsForCall, struct {
		auctioneerPresence models.AuctioneerPresence
		retryInterval      time.Duration
	}{auctioneerPresence, retryInterval})
	fake.newAuctioneerLockMutex.Unlock()
	if fake.NewAuctioneerLockStub != nil {
		return fake.NewAuctioneerLockStub(auctioneerPresence, retryInterval)
	} else {
		return fake.newAuctioneerLockReturns.result1, fake.newAuctioneerLockReturns.result2
	}
}

func (fake *FakeClient) NewAuctioneerLockCallCount() int {
	fake.newAuctioneerLockMutex.RLock()
	defer fake.newAuctioneerLockMutex.RUnlock()
	return len(fake.newAuctioneerLockArgsForCall)
}

func (fake *FakeClient) NewAuctioneerLockArgsForCall(i int) (models.AuctioneerPresence, time.Duration) {
	fake.newAuctioneerLockMutex.RLock()
	defer fake.newAuctioneerLockMutex.RUnlock()
	return fake.newAuctioneerLockArgsForCall[i].auctioneerPresence, fake.newAuctioneerLockArgsForCall[i].retryInterval
}

func (fake *FakeClient) NewAuctioneerLockReturns(result1 ifrit.Runner, result2 error) {
	fake.NewAuctioneerLockStub = nil
	fake.newAuctioneerLockReturns = struct {
		result1 ifrit.Runner
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) NewConvergeLock(convergerID string, retryInterval time.Duration) ifrit.Runner {
	fake.newConvergeLockMutex.Lock()
	fake.newConvergeLockArgsForCall = append(fake.newConvergeLockArgsForCall, struct {
		convergerID   string
		retryInterval time.Duration
	}{convergerID, retryInterval})
	fake.newConvergeLockMutex.Unlock()
	if fake.NewConvergeLockStub != nil {
		return fake.NewConvergeLockStub(convergerID, retryInterval)
	} else {
		return fake.newConvergeLockReturns.result1
	}
}

func (fake *FakeClient) NewConvergeLockCallCount() int {
	fake.newConvergeLockMutex.RLock()
	defer fake.newConvergeLockMutex.RUnlock()
	return len(fake.newConvergeLockArgsForCall)
}

func (fake *FakeClient) NewConvergeLockArgsForCall(i int) (string, time.Duration) {
	fake.newConvergeLockMutex.RLock()
	defer fake.newConvergeLockMutex.RUnlock()
	return fake.newConvergeLockArgsForCall[i].convergerID, fake.newConvergeLockArgsForCall[i].retryInterval
}

func (fake *FakeClient) NewConvergeLockReturns(result1 ifrit.Runner) {
	fake.NewConvergeLockStub = nil
	fake.newConvergeLockReturns = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeClient) NewNsyncBulkerLock(bulkerID string, retryInterval time.Duration) ifrit.Runner {
	fake.newNsyncBulkerLockMutex.Lock()
	fake.newNsyncBulkerLockArgsForCall = append(fake.newNsyncBulkerLockArgsForCall, struct {
		bulkerID      string
		retryInterval time.Duration
	}{bulkerID, retryInterval})
	fake.newNsyncBulkerLockMutex.Unlock()
	if fake.NewNsyncBulkerLockStub != nil {
		return fake.NewNsyncBulkerLockStub(bulkerID, retryInterval)
	} else {
		return fake.newNsyncBulkerLockReturns.result1
	}
}

func (fake *FakeClient) NewNsyncBulkerLockCallCount() int {
	fake.newNsyncBulkerLockMutex.RLock()
	defer fake.newNsyncBulkerLockMutex.RUnlock()
	return len(fake.newNsyncBulkerLockArgsForCall)
}

func (fake *FakeClient) NewNsyncBulkerLockArgsForCall(i int) (string, time.Duration) {
	fake.newNsyncBulkerLockMutex.RLock()
	defer fake.newNsyncBulkerLockMutex.RUnlock()
	return fake.newNsyncBulkerLockArgsForCall[i].bulkerID, fake.newNsyncBulkerLockArgsForCall[i].retryInterval
}

func (fake *FakeClient) NewNsyncBulkerLockReturns(result1 ifrit.Runner) {
	fake.NewNsyncBulkerLockStub = nil
	fake.newNsyncBulkerLockReturns = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeClient) NewRouteEmitterLock(emitterID string, retryInterval time.Duration) ifrit.Runner {
	fake.newRouteEmitterLockMutex.Lock()
	fake.newRouteEmitterLockArgsForCall = append(fake.newRouteEmitterLockArgsForCall, struct {
		emitterID     string
		retryInterval time.Duration
	}{emitterID, retryInterval})
	fake.newRouteEmitterLockMutex.Unlock()
	if fake.NewRouteEmitterLockStub != nil {
		return fake.NewRouteEmitterLockStub(emitterID, retryInterval)
	} else {
		return fake.newRouteEmitterLockReturns.result1
	}
}

func (fake *FakeClient) NewRouteEmitterLockCallCount() int {
	fake.newRouteEmitterLockMutex.RLock()
	defer fake.newRouteEmitterLockMutex.RUnlock()
	return len(fake.newRouteEmitterLockArgsForCall)
}

func (fake *FakeClient) NewRouteEmitterLockArgsForCall(i int) (string, time.Duration) {
	fake.newRouteEmitterLockMutex.RLock()
	defer fake.newRouteEmitterLockMutex.RUnlock()
	return fake.newRouteEmitterLockArgsForCall[i].emitterID, fake.newRouteEmitterLockArgsForCall[i].retryInterval
}

func (fake *FakeClient) NewRouteEmitterLockReturns(result1 ifrit.Runner) {
	fake.NewRouteEmitterLockStub = nil
	fake.newRouteEmitterLockReturns = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeClient) NewRuntimeMetricsLock(runtimeMetricsID string, retryInterval time.Duration) ifrit.Runner {
	fake.newRuntimeMetricsLockMutex.Lock()
	fake.newRuntimeMetricsLockArgsForCall = append(fake.newRuntimeMetricsLockArgsForCall, struct {
		runtimeMetricsID string
		retryInterval    time.Duration
	}{runtimeMetricsID, retryInterval})
	fake.newRuntimeMetricsLockMutex.Unlock()
	if fake.NewRuntimeMetricsLockStub != nil {
		return fake.NewRuntimeMetricsLockStub(runtimeMetricsID, retryInterval)
	} else {
		return fake.newRuntimeMetricsLockReturns.result1
	}
}

func (fake *FakeClient) NewRuntimeMetricsLockCallCount() int {
	fake.newRuntimeMetricsLockMutex.RLock()
	defer fake.newRuntimeMetricsLockMutex.RUnlock()
	return len(fake.newRuntimeMetricsLockArgsForCall)
}

func (fake *FakeClient) NewRuntimeMetricsLockArgsForCall(i int) (string, time.Duration) {
	fake.newRuntimeMetricsLockMutex.RLock()
	defer fake.newRuntimeMetricsLockMutex.RUnlock()
	return fake.newRuntimeMetricsLockArgsForCall[i].runtimeMetricsID, fake.newRuntimeMetricsLockArgsForCall[i].retryInterval
}

func (fake *FakeClient) NewRuntimeMetricsLockReturns(result1 ifrit.Runner) {
	fake.NewRuntimeMetricsLockStub = nil
	fake.newRuntimeMetricsLockReturns = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeClient) NewTpsWatcherLock(tpsWatcherID string, retryInterval time.Duration) ifrit.Runner {
	fake.newTpsWatcherLockMutex.Lock()
	fake.newTpsWatcherLockArgsForCall = append(fake.newTpsWatcherLockArgsForCall, struct {
		tpsWatcherID  string
		retryInterval time.Duration
	}{tpsWatcherID, retryInterval})
	fake.newTpsWatcherLockMutex.Unlock()
	if fake.NewTpsWatcherLockStub != nil {
		return fake.NewTpsWatcherLockStub(tpsWatcherID, retryInterval)
	} else {
		return fake.newTpsWatcherLockReturns.result1
	}
}

func (fake *FakeClient) NewTpsWatcherLockCallCount() int {
	fake.newTpsWatcherLockMutex.RLock()
	defer fake.newTpsWatcherLockMutex.RUnlock()
	return len(fake.newTpsWatcherLockArgsForCall)
}

func (fake *FakeClient) NewTpsWatcherLockArgsForCall(i int) (string, time.Duration) {
	fake.newTpsWatcherLockMutex.RLock()
	defer fake.newTpsWatcherLockMutex.RUnlock()
	return fake.newTpsWatcherLockArgsForCall[i].tpsWatcherID, fake.newTpsWatcherLockArgsForCall[i].retryInterval
}

func (fake *FakeClient) NewTpsWatcherLockReturns(result1 ifrit.Runner) {
	fake.NewTpsWatcherLockStub = nil
	fake.newTpsWatcherLockReturns = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeClient) NewBBSMasterLock(bbsPresence models.BBSPresence, retryInterval time.Duration) (ifrit.Runner, error) {
	fake.newBBSMasterLockMutex.Lock()
	fake.newBBSMasterLockArgsForCall = append(fake.newBBSMasterLockArgsForCall, struct {
		bbsPresence   models.BBSPresence
		retryInterval time.Duration
	}{bbsPresence, retryInterval})
	fake.newBBSMasterLockMutex.Unlock()
	if fake.NewBBSMasterLockStub != nil {
		return fake.NewBBSMasterLockStub(bbsPresence, retryInterval)
	} else {
		return fake.newBBSMasterLockReturns.result1, fake.newBBSMasterLockReturns.result2
	}
}

func (fake *FakeClient) NewBBSMasterLockCallCount() int {
	fake.newBBSMasterLockMutex.RLock()
	defer fake.newBBSMasterLockMutex.RUnlock()
	return len(fake.newBBSMasterLockArgsForCall)
}

func (fake *FakeClient) NewBBSMasterLockArgsForCall(i int) (models.BBSPresence, time.Duration) {
	fake.newBBSMasterLockMutex.RLock()
	defer fake.newBBSMasterLockMutex.RUnlock()
	return fake.newBBSMasterLockArgsForCall[i].bbsPresence, fake.newBBSMasterLockArgsForCall[i].retryInterval
}

func (fake *FakeClient) NewBBSMasterLockReturns(result1 ifrit.Runner, result2 error) {
	fake.NewBBSMasterLockStub = nil
	fake.newBBSMasterLockReturns = struct {
		result1 ifrit.Runner
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) AuctioneerAddress() (string, error) {
	fake.auctioneerAddressMutex.Lock()
	fake.auctioneerAddressArgsForCall = append(fake.auctioneerAddressArgsForCall, struct{}{})
	fake.auctioneerAddressMutex.Unlock()
	if fake.AuctioneerAddressStub != nil {
		return fake.AuctioneerAddressStub()
	} else {
		return fake.auctioneerAddressReturns.result1, fake.auctioneerAddressReturns.result2
	}
}

func (fake *FakeClient) AuctioneerAddressCallCount() int {
	fake.auctioneerAddressMutex.RLock()
	defer fake.auctioneerAddressMutex.RUnlock()
	return len(fake.auctioneerAddressArgsForCall)
}

func (fake *FakeClient) AuctioneerAddressReturns(result1 string, result2 error) {
	fake.AuctioneerAddressStub = nil
	fake.auctioneerAddressReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) BBSMasterURL() (string, error) {
	fake.bBSMasterURLMutex.Lock()
	fake.bBSMasterURLArgsForCall = append(fake.bBSMasterURLArgsForCall, struct{}{})
	fake.bBSMasterURLMutex.Unlock()
	if fake.BBSMasterURLStub != nil {
		return fake.BBSMasterURLStub()
	} else {
		return fake.bBSMasterURLReturns.result1, fake.bBSMasterURLReturns.result2
	}
}

func (fake *FakeClient) BBSMasterURLCallCount() int {
	fake.bBSMasterURLMutex.RLock()
	defer fake.bBSMasterURLMutex.RUnlock()
	return len(fake.bBSMasterURLArgsForCall)
}

func (fake *FakeClient) BBSMasterURLReturns(result1 string, result2 error) {
	fake.BBSMasterURLStub = nil
	fake.bBSMasterURLReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) NewCellPresence(cellPresence models.CellPresence, retryInterval time.Duration) ifrit.Runner {
	fake.newCellPresenceMutex.Lock()
	fake.newCellPresenceArgsForCall = append(fake.newCellPresenceArgsForCall, struct {
		cellPresence  models.CellPresence
		retryInterval time.Duration
	}{cellPresence, retryInterval})
	fake.newCellPresenceMutex.Unlock()
	if fake.NewCellPresenceStub != nil {
		return fake.NewCellPresenceStub(cellPresence, retryInterval)
	} else {
		return fake.newCellPresenceReturns.result1
	}
}

func (fake *FakeClient) NewCellPresenceCallCount() int {
	fake.newCellPresenceMutex.RLock()
	defer fake.newCellPresenceMutex.RUnlock()
	return len(fake.newCellPresenceArgsForCall)
}

func (fake *FakeClient) NewCellPresenceArgsForCall(i int) (models.CellPresence, time.Duration) {
	fake.newCellPresenceMutex.RLock()
	defer fake.newCellPresenceMutex.RUnlock()
	return fake.newCellPresenceArgsForCall[i].cellPresence, fake.newCellPresenceArgsForCall[i].retryInterval
}

func (fake *FakeClient) NewCellPresenceReturns(result1 ifrit.Runner) {
	fake.NewCellPresenceStub = nil
	fake.newCellPresenceReturns = struct {
		result1 ifrit.Runner
	}{result1}
}

func (fake *FakeClient) CellById(cellId string) (models.CellPresence, error) {
	fake.cellByIdMutex.Lock()
	fake.cellByIdArgsForCall = append(fake.cellByIdArgsForCall, struct {
		cellId string
	}{cellId})
	fake.cellByIdMutex.Unlock()
	if fake.CellByIdStub != nil {
		return fake.CellByIdStub(cellId)
	} else {
		return fake.cellByIdReturns.result1, fake.cellByIdReturns.result2
	}
}

func (fake *FakeClient) CellByIdCallCount() int {
	fake.cellByIdMutex.RLock()
	defer fake.cellByIdMutex.RUnlock()
	return len(fake.cellByIdArgsForCall)
}

func (fake *FakeClient) CellByIdArgsForCall(i int) string {
	fake.cellByIdMutex.RLock()
	defer fake.cellByIdMutex.RUnlock()
	return fake.cellByIdArgsForCall[i].cellId
}

func (fake *FakeClient) CellByIdReturns(result1 models.CellPresence, result2 error) {
	fake.CellByIdStub = nil
	fake.cellByIdReturns = struct {
		result1 models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Cells() ([]models.CellPresence, error) {
	fake.cellsMutex.Lock()
	fake.cellsArgsForCall = append(fake.cellsArgsForCall, struct{}{})
	fake.cellsMutex.Unlock()
	if fake.CellsStub != nil {
		return fake.CellsStub()
	} else {
		return fake.cellsReturns.result1, fake.cellsReturns.result2
	}
}

func (fake *FakeClient) CellsCallCount() int {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	return len(fake.cellsArgsForCall)
}

func (fake *FakeClient) CellsReturns(result1 []models.CellPresence, result2 error) {
	fake.CellsStub = nil
	fake.cellsReturns = struct {
		result1 []models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CellEvents() <-chan locket.CellEvent {
	fake.cellEventsMutex.Lock()
	fake.cellEventsArgsForCall = append(fake.cellEventsArgsForCall, struct{}{})
	fake.cellEventsMutex.Unlock()
	if fake.CellEventsStub != nil {
		return fake.CellEventsStub()
	} else {
		return fake.cellEventsReturns.result1
	}
}

func (fake *FakeClient) CellEventsCallCount() int {
	fake.cellEventsMutex.RLock()
	defer fake.cellEventsMutex.RUnlock()
	return len(fake.cellEventsArgsForCall)
}

func (fake *FakeClient) CellEventsReturns(result1 <-chan locket.CellEvent) {
	fake.CellEventsStub = nil
	fake.cellEventsReturns = struct {
		result1 <-chan locket.CellEvent
	}{result1}
}

var _ locket.Client = new(FakeClient)
